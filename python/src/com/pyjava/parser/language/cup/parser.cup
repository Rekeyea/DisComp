// CUP specification for a simple expression evaluator (no actions)
package com.pyjava.parser;

import com.pyjava.core.exceptions.PyException;
import com.pyjava.core.runtime.*;
import java_cup.runtime.*;
import com.pyjava.parser.codegen.*;
import com.pyjava.core.*;
import java.util.Deque;
import java.util.LinkedList;
import java.util.Scanner;



action code
{:

:};


parser code
{:



    public void syntax_error(Symbol s){
        System.out.println("Error de sintaxis "+s.sym+" en la linea "+(s.left+1)+" y la columna "+s.right);
        System.out.println(s.value);
    }
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("Error de sintaxis "+s.sym);
    }

:};

init with
{:
    //MANTENGO UN STACK DE GENERADORES Y PUSHEO EL PRIMERO
    ParserStatus.StackGenerador.push(new Generador());
:};





/* Terminals (tokens returned by the scanner). */

terminal           DEL, FROM, WHILE, AS, ELIF, GLOBAL, WITH, ASSERT, ELSE, IF, PASS, YIELD, BREAK, EXCEPT, IMPORT, CLASS, EXEC, IN, RAISE, CONTINUE, FINALLY, IS, RETURN, DEF, FOR, LAMBDA, TRY, TYPE, PRINT;
terminal           NEWLINE, WHITESPACE, TAB, COMMENT, NAME, ASSIGN, INTEGER, LONG, FLOAT, STRING, STRING3;
terminal           COMA, DOT, COLON, SEMICOLON, RPAREN, LPAREN, RBRACKET, LBRACKET, RCURLY, LCURLY;
terminal           PLUS, MINUS, MULT, DIV, EXP, DIVE, MOD;
terminal           ANDB, ORB, XORB, NOTB, SHIFTL, SHIFTR;
terminal           AND, OR, NOT, EQUALS, DIFF, MINOR, MAJOR, MINOREQ, MAJOREQ;
terminal            INDENT, DEDENT;
terminal            NONE, TRUE, FALSE;


non terminal constant;
non terminal atom;
non terminal assignment;
non terminal binary_operator;
non terminal unary_operator;
non terminal print_stmt;
non terminal expression;
non terminal program;

precedence left OR;
precedence left AND;
precedence left NOT;
precedence left IN, MINOR, MAJOR, MINOREQ, MAJOREQ,DIFF, EQUALS;
precedence left ORB;
precedence left XORB;
precedence left ANDB;
precedence left SHIFTL, SHIFTR;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left NOTB;
precedence right EXP;


program ::= expression NEWLINE
{:
    /*Bloque b1 = (Bloque)a;
    Bloque b2 = (Bloque)b;
    Bloque bRes = ParserStatus.StackGenerador.peek().crearBloque(b1.instrucciones,null,b2.instrucciones);
    Code code = ParserStatus.StackGenerador.peek().crearCodigo("lala","lala",bRes);
    RESULT = code;*/
:};

constant ::= INTEGER:n          {: RESULT = ((LexerToken)n).TokenValue;/*RESULT = RuleGenerator.generateConstant((LexerToken)n);*/ :}
             |LONG:n            {: /*RESULT = RuleGenerator.generateConstant((LexerToken)n);*/ :}
             |FLOAT:n           {: /*RESULT = RuleGenerator.generateConstant((LexerToken)n);*/:}
             |STRING:n          {: /*RESULT = RuleGenerator.generateConstant((LexerToken)n);*/ :}
             |STRING3:n         {: /*RESULT = RuleGenerator.generateConstant((LexerToken)n);*/ :}
             |NONE:n            {: /*RESULT = RuleGenerator.generateConstant((LexerToken)n);*/ :}
             |TRUE:n            {: /*RESULT = RuleGenerator.generateConstant((LexerToken)n);*/ :}
             |FALSE:n           {: /*RESULT = RuleGenerator.generateConstant((LexerToken)n);*/ :};

atom ::=    NAME:n            {: RESULT = ((LexerToken)n).TokenValue;/*RESULT = RuleGenerator.generateName((LexerToken)n);*/ :}
            |constant:n       {: RESULT = n;/*RESULT = n;*/ :};


binary_operator ::= OR
                    | AND
                    | MINOR
                    | MAJOR
                    | MINOREQ
                    | MAJOREQ
                    | DIFF
                    | EQUALS
                    | ORB
                    | XORB
                    | ANDB
                    | SHIFTL
                    | SHIFTR
                    | PLUS
                    | MINUS
                    | MULT
                    | DIV
                    | MOD;

unary_operator ::=  NOT
                    |NOTB;

expression ::=  atom
                |LPAREN expression:n RPAREN {: System.out.println("DETECTA PARENTESIS CON: "+n); :}
                |expression:a binary_operator expression:b {: System.out.println("a: "+a+" b: "+b); :}
                |unary_operator expression;



assignment ::= atom:a ASSIGN:au atom:b {:
                                            /*int lineNumber = ((LexerToken)au).NumeroFila;
                                            LinkedList<Instruccion> instrucciones = new LinkedList<>();
                                            if(b instanceof Const){
                                                instrucciones.add(new Instruccion(lineNumber, OpCode.LOAD_CONST,((Const)b).index));
                                            }else{
                                                instrucciones.add(new Instruccion(lineNumber, OpCode.LOAD_NAME, ((Name)b).index));
                                            }
                                            instrucciones.add(new Instruccion(lineNumber,OpCode.STORE_NAME,((Name)a).index));
                                            RESULT = ParserStatus.StackGenerador.peek().crearBloque(instrucciones,null,null);
                                            */
                                    :};

print_stmt ::= PRINT:p NAME:n       {:
                                        /*
                                        int lineNumber = ((LexerToken)p).NumeroFila;
                                        Name name = ParserStatus.StackGenerador.peek().createName(((LexerToken)n).TokenValue);
                                        LinkedList<Instruccion> instrucciones = new LinkedList<>();
                                        instrucciones.add(new Instruccion(lineNumber, OpCode.LOAD_NAME,(name).index));
                                        instrucciones.add(new Instruccion(lineNumber, OpCode.PRINT_ITEM,0));
                                        instrucciones.add(new Instruccion(lineNumber, OpCode.PRINT_NEWLINE,0));
                                        RESULT = ParserStatus.StackGenerador.peek().crearBloque(instrucciones,null,null);
                                        */
                                    :};



