// CUP specification for a simple expression evaluator (no actions)
package com.pyjava.parser;

import com.pyjava.core.exceptions.PyException;
import com.pyjava.core.runtime.*;
import java_cup.runtime.*;
import com.pyjava.parser.codegen.*;
import com.pyjava.core.*;
import java.util.Deque;
import java.util.LinkedList;
import java.util.Scanner;



action code
{:

:};


parser code
{:



    public void syntax_error(Symbol s){
        System.out.println("Error de sintaxis "+s.sym+" en la linea "+(s.left+1)+" y la columna "+s.right);
        System.out.println(s.value);
    }
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("Error de sintaxis "+s.sym);
    }

:};

init with
{:
    //MANTENGO UN STACK DE GENERADORES Y PUSHEO EL PRIMERO
    ParserStatus.StackGenerador.push(new Generador());
:};





/* Terminals (tokens returned by the scanner). */

terminal           DEL, FROM, WHILE, AS, ELIF, GLOBAL, WITH, ASSERT, ELSE, IF, PASS, YIELD, BREAK, EXCEPT, IMPORT, CLASS, EXEC, IN, RAISE, CONTINUE, FINALLY, IS, RETURN, DEF, FOR, LAMBDA, TRY, TYPE, PRINT;
terminal           NEWLINE, WHITESPACE, TAB, COMMENT, NAME, ASSIGN, INTEGER, LONG, FLOAT, STRING, STRING3;
terminal           COMA, DOT, COLON, SEMICOLON, RPAREN, LPAREN, RBRACKET, LBRACKET, RCURLY, LCURLY;
terminal           PLUS, MINUS, MULT, DIV, EXP, DIVE, MOD;
terminal           ANDB, ORB, XORB, NOTB, SHIFTL, SHIFTR;
terminal           AND, OR, NOT, EQUALS, DIFF, MINOR, MAJOR, MINOREQ, MAJOREQ;
terminal            INDENT, DEDENT;
terminal            NONE, TRUE, FALSE;


non terminal constant;
non terminal atom;
non terminal assignment;
non terminal binary_operator;
non terminal unary_operator;
non terminal print_stmt;
non terminal expression;
non terminal testcoma;
non terminal testlist;
non terminal return_stmt;
non terminal namecoma;
non terminal namelist;
non terminal expr_stmt;
non terminal argument;
non terminal named_argument;
non terminal named_argument_list;
non terminal argument_list;
non terminal trailer;
non terminal func_call;
non terminal integer;
non terminal float;
non terminal long;
non terminal flow_stmt;
non terminal small_stmt;
non terminal stmt;
non terminal compound_stmt;
non terminal if_stmt;
non terminal while_stmt;
non terminal for_stmt;
non terminal func_def;
non terminal stmt_list;
non terminal suite;
non terminal name;

non terminal program;

precedence left OR;
precedence left AND;
precedence left NOT;
precedence left IN, MINOR, MAJOR, MINOREQ, MAJOREQ,DIFF, EQUALS;
precedence left ORB;
precedence left XORB;
precedence left ANDB;
precedence left SHIFTL, SHIFTR;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD, DIVE;
precedence left EXP;
precedence left NOTB;
precedence right COMA;
precedence right ASSIGN;
precedence left DOT;

program ::= print_stmt:b NEWLINE
{:
    System.out.println("EL PROGRAMA ESTA BIEN");
    Bloque bloq = ParseResult.getAs(b);
    Code code = ParserStatus.StackGenerador.peek().crearCodigo("lala","lala",bloq);
    RESULT = code;
:};

integer ::=    INTEGER:n                {: RESULT = RuleGenerator.generateConstant(n); :}
               |MINUS INTEGER:n        {: RESULT = RuleGenerator.generateMinusConstant(n); :};

long ::=   LONG:n                       {: RESULT = RuleGenerator.generateConstant(n); :}
           |MINUS LONG:n               {: RESULT = RuleGenerator.generateMinusConstant(n); :};

float ::=   FLOAT:n                     {: RESULT = RuleGenerator.generateConstant(n); :}
            |MINUS FLOAT:n             {: RESULT = RuleGenerator.generateMinusConstant(n); :};

constant ::= integer:n          {: RESULT = n; :}
             |long:n            {: RESULT = n; :}
             |float:n           {: RESULT = n; :}
             |STRING:n          {: RESULT = RuleGenerator.generateConstant(n); :}
             |STRING3:n         {: RESULT = RuleGenerator.generateConstant(n); :}
             |NONE:n            {: RESULT = RuleGenerator.generateConstant(n); :}
             |TRUE:n            {: RESULT = RuleGenerator.generateConstant(n); :}
             |FALSE:n           {: RESULT = RuleGenerator.generateConstant(n); :};

name ::= NAME:n  {:RESULT = RuleGenerator.generateName((LexerToken)n); :};

atom ::=    name:n            {: RESULT = n; :}
            |constant:n       {: RESULT = n; :}
            |func_call;


/*
argument ::=    expression;
named_argument ::= NAME ASSIGN expression;
named_argument_list ::= named_argument
                        |named_argument COMA named_argument_list;
argument_list ::=   argument
                    |argument COMA argument_list
                    |named_argument_list;*/

binary_operator ::= OR:n            {: RESULT = n; :}
                    | AND:n         {: RESULT = n; :}
                    | MINOR:n       {: RESULT = n; :}
                    | MAJOR:n       {: RESULT = n; :}
                    | MINOREQ:n     {: RESULT = n; :}
                    | MAJOREQ:n     {: RESULT = n; :}
                    | DIFF:n        {: RESULT = n; :}
                    | EQUALS:n      {: RESULT = n; :}
                    | ORB:n         {: RESULT = n; :}
                    | XORB:n        {: RESULT = n; :}
                    | ANDB:n        {: RESULT = n; :}
                    | SHIFTL:n      {: RESULT = n; :}
                    | SHIFTR:n      {: RESULT = n; :}
                    | PLUS:n        {: RESULT = n; :}
                    | MINUS:n       {: RESULT = n; :}
                    | MULT:n        {: RESULT = n; :}
                    | DIV:n         {: RESULT = n; :}
                    | MOD:n         {: RESULT = n; :}
                    | DIVE:n        {: RESULT = n; :}
                    | EXP:n         {: RESULT = n; :};

unary_operator ::=  NOT
                    |NOTB;

expression ::=  atom:n                                          {: RESULT = RuleGenerator.loadNameOrConst(n); :}
                |LPAREN expression:n RPAREN                     {: RESULT = n; :}
                |expression:a binary_operator:op expression:b   {: RESULT = RuleGenerator.generateBinaryOperation(op,a,b); :}
                |unary_operator:op expression:a                 {: RESULT = RuleGenerator.generateUnaryOperation(op,a); :};



/*assignment ::= atom:a ASSIGN:au expression:b
                                    {:
                                            int lineNumber = ((LexerToken)au).NumeroFila;
                                            LinkedList<Instruccion> instrucciones = new LinkedList<>();
                                            if(b instanceof Const){
                                                instrucciones.add(new Instruccion(lineNumber, OpCode.LOAD_CONST,((Const)b).index));
                                            }else{
                                                instrucciones.add(new Instruccion(lineNumber, OpCode.LOAD_NAME, ((Name)b).index));
                                            }
                                            instrucciones.add(new Instruccion(lineNumber,OpCode.STORE_NAME,((Name)a).index));
                                            RESULT = ParserStatus.StackGenerador.peek().crearBloque(instrucciones,null,null);

                                    :};*/

print_stmt ::= PRINT:p expression:n {: RESULT = RuleGenerator.generatePrint(p,n); :};


/*
testcoma ::=    COMA expression             {: System.out.println("TESTCOMA 1"); :}
                |COMA expression testcoma   {: System.out.println("TESTCOMA 2"); :};

testlist ::=    expression                  {: System.out.println("TESTLIST 1"); :}
                |expression COMA            {: System.out.println("TESTLIST 2"); :}
                |expression testcoma        {: System.out.println("TESTLIST 3"); :}
                |expression testcoma COMA   {: System.out.println("TESTLIST 4"); :};


return_stmt ::= RETURN
                |RETURN testlist;

namecoma ::=    COMA NAME
                |COMA NAME namecoma;
namelist ::=    NAME
                |NAME namecoma;


expr_stmt ::=   namelist ASSIGN testlist;


trailer ::= LPAREN RPAREN
            |LPAREN argument_list RPAREN;

func_call ::=   expression DOT NAME trailer
                |NAME trailer;

flow_stmt ::=   BREAK
                |CONTINUE
                |return_stmt;

small_stmt ::=  expr_stmt
                |expression
                |print_stmt
                |flow_stmt;

stmt ::=    small_stmt NEWLINE
            |compound_stmt NEWLINE;

compound_stmt ::=   if_stmt
                    |while_stmt
                    |for_stmt
                    |func_def;

stmt_list ::=   stmt
                |stmt stmt_list;

suite ::=   stmt
            |NEWLINE INDENT stmt_list DEDENT;


if_stmt ::=     IF expression COLON suite NEWLINE
                |IF expression COLON suite NEWLINE ELSE COLON suite NEWLINE;


*/

