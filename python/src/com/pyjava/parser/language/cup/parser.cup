// CUP specification for a simple expression evaluator (no actions)
package com.pyjava.parser;

import com.pyjava.core.exceptions.PyException;
import com.pyjava.core.runtime.*;
import java_cup.runtime.*;
import com.pyjava.parser.codegen.*;
import com.pyjava.core.*;
import java.util.Deque;
import java.util.LinkedList;
import java.util.Scanner;



action code
{:

:};


parser code
{:



    public void syntax_error(Symbol s){
        System.out.println("Error de sintaxis "+s.sym+" en la linea "+(s.left+1)+" y la columna "+s.right);
        System.out.println(s.value);
    }
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("Error de sintaxis "+s.sym);
    }

:};

init with
{:
    //MANTENGO UN STACK DE GENERADORES Y PUSHEO EL PRIMERO
    ParserStatus.StackGenerador.push(new Generador());
:};





/* Terminals (tokens returned by the scanner). */

terminal           DEL, FROM, WHILE, AS, ELIF, GLOBAL, WITH, ASSERT, ELSE, IF, PASS, YIELD, BREAK, EXCEPT, IMPORT, CLASS, EXEC, IN, RAISE, CONTINUE, FINALLY, IS, RETURN, DEF, FOR, LAMBDA, TRY, TYPE, PRINT;
terminal           NEWLINE, WHITESPACE, TAB, COMMENT, NAME, ASSIGN, INTEGER, LONG, FLOAT, STRING, STRING3;
terminal           COMA, DOT, COLON, SEMICOLON, RPAREN, LPAREN, RBRACKET, LBRACKET, RCURLY, LCURLY;
terminal           PLUS, MINUS, MULT, DIV, EXP, DIVE, MOD;
terminal           ANDB, ORB, XORB, NOTB, SHIFTL, SHIFTR;
terminal           AND, OR, NOT, EQUALS, DIFF, MINOR, MAJOR, MINOREQ, MAJOREQ;
terminal            INDENT, DEDENT;
terminal            NONE, TRUE, FALSE;


non terminal atom;
non terminal assignment;
non terminal print_stmt;
non terminal program;


program ::= assignment:a NEWLINE print_stmt:b NEWLINE
{:
    Bloque b1 = (Bloque)a;
    Bloque b2 = (Bloque)b;
    Bloque bRes = ParserStatus.StackGenerador.peek().crearBloque(b1.instrucciones,null,b2.instrucciones);
    Code code = ParserStatus.StackGenerador.peek().crearCodigo("lala","lala",bRes);
    RESULT = code;
:};

atom ::=    NAME:n            {: RESULT = ParserStatus.StackGenerador.peek().createName(((LexerToken)n).TokenValue); :}
            |INTEGER:n        {: RESULT = ParserStatus.StackGenerador.peek().createConst(ConstCreator.createPyInt(((LexerToken)n).TokenValue)); :}
            |LONG
            |FLOAT
            |STRING
            |STRING3
            |NONE
            |TRUE
            |FALSE;

assignment ::= atom:a ASSIGN:au atom:b {:
                                            int lineNumber = ((LexerToken)au).NumeroFila;
                                            LinkedList<Instruccion> instrucciones = new LinkedList<>();
                                            if(b instanceof Const){
                                                instrucciones.add(new Instruccion(lineNumber, OpCode.LOAD_CONST,((Const)b).index));
                                            }else{
                                                instrucciones.add(new Instruccion(lineNumber, OpCode.LOAD_NAME, ((Name)b).index));
                                            }
                                            instrucciones.add(new Instruccion(lineNumber,OpCode.STORE_NAME,((Name)a).index));
                                            RESULT = ParserStatus.StackGenerador.peek().crearBloque(instrucciones,null,null);

                                    :};

print_stmt ::= PRINT:p NAME:n       {:
                                        int lineNumber = ((LexerToken)p).NumeroFila;
                                        Name name = ParserStatus.StackGenerador.peek().createName(((LexerToken)n).TokenValue);
                                        LinkedList<Instruccion> instrucciones = new LinkedList<>();
                                        instrucciones.add(new Instruccion(lineNumber, OpCode.LOAD_NAME,(name).index));
                                        instrucciones.add(new Instruccion(lineNumber, OpCode.PRINT_ITEM,0));
                                        instrucciones.add(new Instruccion(lineNumber, OpCode.PRINT_NEWLINE,0));
                                        RESULT = ParserStatus.StackGenerador.peek().crearBloque(instrucciones,null,null);
                                    :};



